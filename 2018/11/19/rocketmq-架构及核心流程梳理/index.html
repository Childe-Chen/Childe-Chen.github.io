<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一直在用rocketmq，对他的功能和大概流程略知一些，但是比较浮，经不起稍微的推敲。是时候进一步了解下这个NB的中间件了。 这里不再赘述它的那些特性，网上一大堆，这里主要按照自己想了解的一些方面作整理，贴出部分核心代码，意图通过表现各个角色间的交互，勾画大致架构，方便以后对每个要点各个深入。如果想要引导来阅读源代码，推荐rmq源码系列，写的很有诚意，本笔记中也部分参考引用其文章。 部署结构（逻辑">
<meta property="og:type" content="article">
<meta property="og:title" content="rocketmq-半入门级架构及核心流程概览">
<meta property="og:url" content="http://yoursite.com/2018/11/19/rocketmq-%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/index.html">
<meta property="og:site_name" content="凡隐的博客">
<meta property="og:description" content="一直在用rocketmq，对他的功能和大概流程略知一些，但是比较浮，经不起稍微的推敲。是时候进一步了解下这个NB的中间件了。 这里不再赘述它的那些特性，网上一大堆，这里主要按照自己想了解的一些方面作整理，贴出部分核心代码，意图通过表现各个角色间的交互，勾画大致架构，方便以后对每个要点各个深入。如果想要引导来阅读源代码，推荐rmq源码系列，写的很有诚意，本笔记中也部分参考引用其文章。 部署结构（逻辑">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://res.cloudinary.com/childe/image/upload/v1544699305/blog/mq/rmq%E7%89%A9%E7%90%86%E9%83%A8%E7%BD%B2%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https://res.cloudinary.com/childe/image/upload/v1544699304/blog/mq/rmq%E9%80%BB%E8%BE%91%E9%83%A8%E7%BD%B2%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https://res.cloudinary.com/childe/image/upload/v1544699167/blog/mq/rmq%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://res.cloudinary.com/childe/image/upload/v1544697820/blog/mq/rmq%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AC%E6%8D%A2.png">
<meta property="article:published_time" content="2018-11-19T06:32:38.000Z">
<meta property="article:modified_time" content="2021-10-30T17:01:17.448Z">
<meta property="article:author" content="childe.chen">
<meta property="article:tag" content="架构">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="MQ">
<meta property="article:tag" content="rocketmq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://res.cloudinary.com/childe/image/upload/v1544699305/blog/mq/rmq%E7%89%A9%E7%90%86%E9%83%A8%E7%BD%B2%E7%BB%93%E6%9E%84.jpg">

<link rel="canonical" href="http://yoursite.com/2018/11/19/rocketmq-%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>rocketmq-半入门级架构及核心流程概览 | 凡隐的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">凡隐的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">平凡的世界</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/rocketmq-%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/childe/image/upload/v1535291056/1_myjcxd.png">
      <meta itemprop="name" content="childe.chen">
      <meta itemprop="description" content="少爷凡隐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凡隐的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rocketmq-半入门级架构及核心流程概览
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-19 14:32:38" itemprop="dateCreated datePublished" datetime="2018-11-19T14:32:38+08:00">2018-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-31 01:01:17" itemprop="dateModified" datetime="2021-10-31T01:01:17+08:00">2021-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>一直在用rocketmq，对他的功能和大概流程略知一些，但是比较浮，经不起稍微的推敲。是时候进一步了解下这个NB的中间件了。</p>
<p>这里不再赘述它的那些特性，网上一大堆，这里主要按照自己想了解的一些方面作整理，贴出部分核心代码，意图通过表现各个角色间的交互，勾画大致架构，方便以后对每个要点各个深入。如果想要引导来阅读源代码，推荐<a target="_blank" rel="noopener" href="https://fdx321.github.io/2017/08/16/%E3%80%90RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%911-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/">rmq源码系列</a>，写的很有诚意，本笔记中也部分参考引用其文章。</p>
<h2 id="部署结构（逻辑结构-物理结构）"><a href="#部署结构（逻辑结构-物理结构）" class="headerlink" title="部署结构（逻辑结构/物理结构）"></a>部署结构（逻辑结构/物理结构）</h2><p>消息中间件的整体看起来像我们相互邮寄明信片。李雷（Producer）通过邮局公告（Namesrv）找到邮局的地址，然后去邮局（Broker）把明信片（Message）发送给韩梅梅（Consumer）。<br><span id="more"></span></p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><ul>
<li><p>Producer  消息生产者，负责产生消息，一般由业务系统负责产生消息。</p>
</li>
<li><p>Consumer  消息消费者，负责消费消息，一般是后台系统负责异步消费。</p>
</li>
<li><p>Broker  消息中转角色，负责存储消息，转发消息，一般也称为 Server。</p>
</li>
<li><p>Namesrv 注册中心，管理协调角色，维护其他角色信息。</p>
</li>
</ul>
<p><img src="https://res.cloudinary.com/childe/image/upload/v1544699305/blog/mq/rmq%E7%89%A9%E7%90%86%E9%83%A8%E7%BD%B2%E7%BB%93%E6%9E%84.jpg" alt="rmq物理部署.png"></p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构里面把所有角色都集群化了，集群化后就要牵扯到集群消费。于是，基于以上的角色，又衍生出其他的概念。</p>
<ul>
<li><p>Producer Group  一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</p>
</li>
<li><p>Consumer Group  一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</p>
</li>
</ul>
<p><img src="https://res.cloudinary.com/childe/image/upload/v1544699304/blog/mq/rmq%E9%80%BB%E8%BE%91%E9%83%A8%E7%BD%B2%E7%BB%93%E6%9E%84.jpg" alt="rmq逻辑部署.png"></p>
<h2 id="角色实现及其交互"><a href="#角色实现及其交互" class="headerlink" title="角色实现及其交互"></a>角色实现及其交互</h2><p>按照逻辑/物理部署结构，各个角色间怎么通信？怎么保活？数据怎么备份？</p>
<p>rmq自己对Netty进行了包装（<a target="_blank" rel="noopener" href="http://childe.net.cn/2017/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BFacade/">Facade</a>），方便各个角色使用，在工程的<strong>remoting</strong>子工程中。</p>
<h3 id="namesrv-Name-Server-与broker"><a href="#namesrv-Name-Server-与broker" class="headerlink" title="namesrv(Name Server)与broker"></a>namesrv(Name Server)与broker</h3><p>namesrv与broker是实现后续一切的基础，producer和consumer的信息传递需要broker来中转，那么找到或者说确定一个broker便是第一步了。</p>
<h4 id="namesrv-Name-Server"><a href="#namesrv-Name-Server" class="headerlink" title="namesrv(Name Server)"></a>namesrv(Name Server)</h4><p>namesrv是很轻量的服务，简单、可集群横向扩展、无状态。他是整个mq的管家（像是Dubbo的服务发现），管理其他角色，如果没有它，整个mq将难以开展工作。</p>
<p>简单看下namesrv启动时的行为。它的核心代码在工程的<strong>namesrv</strong>包下，代码量很少。</p>
<p>namesrv的故事开始于<code>NamesrvStartup</code>的main方法，它主要来解析配置参数，根据配置装填并初始化和启动<code>NamesrvController</code>。<code>NamesrvController</code>贯连整个Namesrv的业务功能，通过Netty向外暴露服务，主要负责：</p>
<ul>
<li><p>管理Topic和Broker的注册信息</p>
</li>
<li><p>管理KV的配置（持久化）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NamesrvController</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 管理KV的配置（并持久化）</span></span><br><span class="line">    <span class="built_in">this</span>.kvConfigManager.load();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 暴露服务</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// netty执行线程池</span></span><br><span class="line">    <span class="built_in">this</span>.remotingExecutor =</span><br><span class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> <span class="title class_">ThreadFactoryImpl</span>(<span class="string">&quot;RemotingExecutorThread_&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册服务处理器</span></span><br><span class="line">    <span class="built_in">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// kv信息打印及broker存活检测任务</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            NamesrvController.<span class="built_in">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略TSL配置部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RouteInfoManager</code>相当于是管家的账本，里面保存着关于topic、broker的具体信息，这些信息全部保存在内存中。其维护的信息如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RouteInfoManager</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* BrokerData &#123;</span></span><br><span class="line"><span class="comment">* 	private String cluster;</span></span><br><span class="line"><span class="comment">* 	private String brokerName;</span></span><br><span class="line"><span class="comment">* 	private HashMap&lt;Long/* brokerId */</span>, String<span class="comment">/* broker address */</span>&gt; brokerAddrs;</span><br><span class="line">* &#125;</span><br><span class="line">**/</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* BrokerLiveInfo &#123;</span></span><br><span class="line"><span class="comment">* 	private long lastUpdateTimestamp;</span></span><br><span class="line"><span class="comment">* 	private DataVersion dataVersion;</span></span><br><span class="line"><span class="comment">* 	private Channel channel;</span></span><br><span class="line"><span class="comment">* 	private String haServerAddr;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，这些信息从哪里来呢？且慢，我们先看下broker。</p>
<h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h4><p>broker就是例子中邮局，邮局要具备什么能力呢？</p>
<ol>
<li>接收信件</li>
<li>保存信件，保证除不可抗因素外，信件不丢失</li>
<li>投递信件</li>
<li>高效工作，信件快速接受及送达</li>
<li>信件投递失败的处理</li>
<li>信件投递可回溯追踪（当然，邮局不能看内容了）</li>
<li>向管家（namesrv）汇报自己的运营状态</li>
</ol>
<p>以上这些其实也就是broker要做的事情，只不过它不存在隐私一说罢了。当然他还需要有其他的特性。</p>
<ol>
<li>支持消息的不同投递模型：Publish/Subscribe，集群分组消费等</li>
<li>高可用，无单点</li>
<li>消息有序</li>
<li>消息过滤</li>
<li>分布式事务</li>
</ol>
<p>broker的主要源码放在broker目录下，broker（其他模块）的启动模型与namesrv一致，<code>BrokerStartup</code>解析配置，并根据配置装备<code>BrokerController</code>，然后初始化<code>BrokerController</code>并启动（start）。进行初始化时的主要启动一堆定时任务、存储（MessageStore）和Netty配置（注册Processor）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BrokerController</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.topicConfigManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者消费信息</span></span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.consumerOffsetManager.load();</span><br><span class="line">    <span class="comment">// 订阅组</span></span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.subscriptionGroupManager.load();</span><br><span class="line">    <span class="comment">// 过滤器</span></span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.consumerFilterManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略messageStore相关处理</span></span><br><span class="line">    result = result &amp;&amp; <span class="built_in">this</span>.messageStore.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// 暴露服务，启动两个Server，小端口和VIPChannel有关</span></span><br><span class="line">        <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.clientHousekeepingService);</span><br><span class="line">        <span class="type">NettyServerConfig</span> <span class="variable">fastConfig</span> <span class="operator">=</span> (NettyServerConfig) <span class="built_in">this</span>.nettyServerConfig.clone();</span><br><span class="line">        fastConfig.setListenPort(nettyServerConfig.getListenPort() - <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">this</span>.fastRemotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(fastConfig, <span class="built_in">this</span>.clientHousekeepingService);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略创建各Processor的Executor</span></span><br><span class="line">		<span class="comment">// 注册Processor</span></span><br><span class="line">        <span class="built_in">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 持久化消费信息</span></span><br><span class="line">        <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            BrokerController.<span class="built_in">this</span>.consumerOffsetManager.persist();</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="built_in">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 持久化过滤器信息</span></span><br><span class="line">        <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            BrokerController.<span class="built_in">this</span>.consumerFilterManager.persist();</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置namesrv地址，如果没有设置，则从一个web服务fetch</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.brokerConfig.getNamesrvAddr() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.brokerOuterAPI.updateNameServerAddressList(<span class="built_in">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.brokerConfig.isFetchNamesrvAddrByAddressServer()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">				BrokerController.<span class="built_in">this</span>.brokerOuterAPI.fetchNameServerAddr();</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (BrokerRole.SLAVE == <span class="built_in">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">            <span class="comment">// 同步topic、consumerOffset、订阅组等信息到Salve</span></span><br><span class="line">            <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                BrokerController.<span class="built_in">this</span>.slaveSynchronize.syncAll();</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是Master则定时打印与Salve的差异</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略TSL设置及事物初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 省略 启动初始化的那些服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向所有namesrv注册自己</span></span><br><span class="line">    <span class="built_in">this</span>.registerBrokerAll(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时向所有namesrv注册自己</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        BrokerController.<span class="built_in">this</span>.registerBrokerAll(<span class="literal">true</span>, <span class="literal">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerBrokerAll</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> checkOrderConfig, <span class="type">boolean</span> oneway, <span class="type">boolean</span> forceRegister)</span> &#123;</span><br><span class="line">	<span class="comment">// 封装broker上的topic信息</span></span><br><span class="line">    <span class="type">TopicConfigSerializeWrapper</span> <span class="variable">topicConfigWrapper</span> <span class="operator">=</span> <span class="built_in">this</span>.getTopicConfigManager().buildTopicConfigSerializeWrapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用API向namesrv注册</span></span><br><span class="line">    doRegisterBrokerAll(checkOrderConfig, oneway, topicConfigWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们可以看到的交互，每个broker启动时会先对namesrv寻址，然后把自己的信息注册到所有的namesrv上，并定时维护（心跳），namesrv维护的关于broker的信息来源于此，为了应对不同的场景需要，namesrv把数据封装成不同的结构，方面维护。namesrv关于请求的处理在<code>DefaultRequestProcessor</code>中，透过其processRequest方法我们可以明确其要承担的全部责任，比如：broker注册/注销，增删改查topic路由，KV信息维护等。broker注册的信息包括但是不限于以下内容。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;topicConfigSerializeWrapper&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;topicConfigTable&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;topic_?&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;defaultReadQueueNums&quot;</span><span class="punctuation">:</span><span class="string">&quot;16&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;defaultWriteQueueNums&quot;</span><span class="punctuation">:</span><span class="string">&quot;16&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;topicName&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;readQueueNums&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;writeQueueNums&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;perm&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;topicFilterType&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;topicSysFlag&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dataVersion&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;counter&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxx&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filterServerList&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">     <span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="comment">//filterServerAddr</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;clusterName&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;brokerAddr&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;brokerName&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;brokerId&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="namesrv与producer"><a href="#namesrv与producer" class="headerlink" title="namesrv与producer"></a>namesrv与producer</h3><p>公告（namesrv）维护好了，李雷（producer）就可以通过它来获取邮局（broker）的信息了。</p>
<p>先来看下producer的启动时主要做了些什么事情，producer的主要代码放在工程的client子工程下的producer包中。抛开事务不谈，我们的入口在<code>DefaultMQProducer</code>的start方法上。<br>下面列出启动时我们关心的业务，启动流程时序图，网上也不少了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultMQProducerImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> startFactory)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="built_in">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">            <span class="comment">// groupName合法性校验</span></span><br><span class="line">            <span class="built_in">this</span>.checkConfig();</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// MixAll.CLIENT_INNER_PRODUCER_GROUP 用来发送消费者消费失败的消息到重试队列</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">                <span class="comment">// 如果不是内部构建的</span></span><br><span class="line">                <span class="built_in">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// MQClientManager 以 clientId（ip@pid） 维度保证 MQClientInstance 的单例</span></span><br><span class="line">            <span class="built_in">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="built_in">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 向 MQClientInstance 注册自己</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">registerOK</span> <span class="operator">=</span> mQClientFactory.registerProducer(<span class="built_in">this</span>.defaultMQProducer.getProducerGroup(), <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="built_in">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// Just for testing or demo program</span></span><br><span class="line">            <span class="built_in">this</span>.topicPublishInfoTable.put(<span class="built_in">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> <span class="title class_">TopicPublishInfo</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">                <span class="comment">// 启动MQClientInstance</span></span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 向broker发送心跳&amp;&amp;上传filter信息</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要说下rmq中client（Producer、Consumer和Admin）的基本结构，不同角色的client通过<a target="_blank" rel="noopener" href="http://childe.net.cn/2017/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E4%B9%8BComposite/">Composite</a>一个<code>MQClientInstance</code>的方式封装各自不同的逻辑，所以他们的启动流程大概一致，Consumer的复杂一些，但主流程无差别：</p>
<ol>
<li>通过clientId获取<code>MQClientInstance</code>实例</li>
<li>自己角色特有的逻辑</li>
<li>向<code>MQClientInstance</code>注册自己</li>
<li>启动<code>MQClientInstance</code>，如果<code>MQClientInstance</code>已启动则返回</li>
<li>通过<code>MQClientInstance</code>方法同步更新自己角色需要的信息</li>
</ol>
<p>按照以上总结我们着重看下<code>MQClientInstance</code>的start做了些什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MQClientInstance</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="built_in">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If not specified,looking address from name server</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == <span class="built_in">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start request-response channel</span></span><br><span class="line">            <span class="comment">// 启动remotingClient，开启与外部交互的通道</span></span><br><span class="line">            <span class="built_in">this</span>.mQClientAPIImpl.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start various schedule tasks</span></span><br><span class="line">            <span class="built_in">this</span>.startScheduledTask();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start pull service</span></span><br><span class="line">            <span class="comment">// push模式下拉消息服务</span></span><br><span class="line">            <span class="built_in">this</span>.pullMessageService.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start rebalance service</span></span><br><span class="line">            <span class="comment">// 开启负载均衡消费队列服务</span></span><br><span class="line">            <span class="built_in">this</span>.rebalanceService.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start push service</span></span><br><span class="line">            <span class="comment">// 上个代码片段提到的 CLIENT_INNER_PRODUCER_GROUP 对应的Producer</span></span><br><span class="line">            <span class="built_in">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The Factory object[&quot;</span> + <span class="built_in">this</span>.getClientId() + <span class="string">&quot;] has been created before, and failed.&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startScheduledTask</span><span class="params">()</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果没有配置namesrv的地址，默认从web服务定时抓取</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == <span class="built_in">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            MQClientInstance.<span class="built_in">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从namesrv（NamesrvController）获取topic的路由信息</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">		MQClientInstance.<span class="built_in">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class="line">    &#125;, <span class="number">10</span>, <span class="built_in">this</span>.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和broker的交互</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 清理已离线的Broker</span></span><br><span class="line">    	MQClientInstance.<span class="built_in">this</span>.cleanOfflineBroker();</span><br><span class="line">        <span class="comment">// 向所有Broker发送心跳，心跳中带有consumer相关信息：clientId，Subscription等</span></span><br><span class="line">        MQClientInstance.<span class="built_in">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="built_in">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持久化消费偏移量（持久化到远程或者本地）</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    	MQClientInstance.<span class="built_in">this</span>.persistAllConsumerOffset();</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="built_in">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 调整push方式下的拉取线程数</span></span><br><span class="line">    <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    	MQClientInstance.<span class="built_in">this</span>.adjustThreadPool();</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MQClientInstance</code>启动时会启动一个从namesrv定时搜集本地所有订阅（consumer）的和发送（producer）的topic，然后依次通过<code>mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, 1000 * 3)</code>来进行更新topic的路由信息。</p>
<blockquote>
<p>问题：负载均衡怎么做的？</p>
</blockquote>
<h3 id="namesrv与consumer"><a href="#namesrv与consumer" class="headerlink" title="namesrv与consumer"></a>namesrv与consumer</h3><p>正如上文说的那样，Producer和Consumer都组合了<code>MQClientInstance</code>，而<code>MQClientInstance</code>来完成其和namesrv的交互，所以它的过程和producer是一致的，他们需要维护的信息也是一致的。</p>
<h3 id="producer与broker"><a href="#producer与broker" class="headerlink" title="producer与broker"></a>producer与broker</h3><p>producer与broker的交互有以下几个关注点：producer支持发送消息的方式？发送失败producer怎么处理？broker怎么处理producer的消息？</p>
<h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>producer发送方式有SYNC、ASYNC、ONEWAY，这些方式定义在<code>CommunicationMode</code>中，但是这块从<code>DefaultMQProducer</code>定义的send方法命名中没有明确区分同步和异步，在我当前的版本中ASYNC的实现存在问题（It will be removed at 4.4.0 cause for exception handling and the wrong Semantics of timeout.）。</p>
<p>我们以最简单的入口（<code>DefaultMQProducer#send(Message)</code>）大致看下producer的发送流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultMQProducerImpl</span></span><br><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendDefaultImpl</span><span class="params">(</span></span><br><span class="line"><span class="params">        Message msg,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> CommunicationMode communicationMode,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SendCallback sendCallback,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> timeout</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略合法性检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">invokeID</span> <span class="operator">=</span> random.nextLong();</span><br><span class="line">    <span class="type">long</span> <span class="variable">beginTimestampFirst</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">beginTimestampPrev</span> <span class="operator">=</span> beginTimestampFirst;</span><br><span class="line">    <span class="comment">// 选择发送topic信息，此步骤数据由·MQClientInstance·中启动的定时任务维护</span></span><br><span class="line">    <span class="type">TopicPublishInfo</span> <span class="variable">topicPublishInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="literal">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">callTimeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 同步模式下，总发送次数确定，默认失败重试2次，也就是共尝试发送3次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">timesTotal</span> <span class="operator">=</span> communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="built_in">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">lastBrokerName</span> <span class="operator">=</span> <span class="literal">null</span> == mq ? <span class="literal">null</span> : mq.getBrokerName();</span><br><span class="line">            <span class="comment">// 选择本次发送的队列</span></span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mqSelected</span> <span class="operator">=</span> <span class="built_in">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">            <span class="keyword">if</span> (mqSelected != <span class="literal">null</span>) &#123;</span><br><span class="line">                mq = mqSelected;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                    <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">                        callTimeout = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 超时中断</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 封装信息，并调用ClientAPI发送出去</span></span><br><span class="line">                    sendResult = <span class="built_in">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">// 更新本次borker可用性，如果sendLatencyFaultEnable开启</span></span><br><span class="line">                    <span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">// 如果SYNC模式下发送失败进行重试，ASYNC和ONEWAY模式下直接返回null</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 根据不同的异常类型确认处理方式：重试、中断、返回</span></span><br><span class="line">                    <span class="comment">// 更新本次borker可用性，如果sendLatencyFaultEnable开启</span></span><br><span class="line">                	<span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有可用队列不进行发送</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么发送消息的怎么确认发送队列呢？sendLatencyFaultEnable是什么？</p>
<p>先通过topic找到对应的topicPublishInfo，顾名思义topicPublishInfo里面维护了该topic相关的broker和队列信息，在没有开启sendLatencyFaultEnable情况下（默认），按照递增取模的方式选择即将要发送的队列，如果开启了sendLatencyFaultEnable，再取模后还需要判断当前队列的broker是否可用。上面代码中我们可以看到发送消息后，不管成功还是失败都会更新一个叫做Item的状态，这个Item指的就是broker，rmq根据此次消耗的时间来更新该broker不可用的时间，以此达到对不稳定broker的规避。具体代码可看·MQFaultStrategy·。</p>
<h4 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h4><p>上面说到<code>BrokerController</code>时，我们未贴出关于broker的NettyServer关于Processor的注册部分。在这部分中，注册了不同的Processor：</p>
<ol>
<li>SendMessageProcessor 处理client发送的消息</li>
<li>PullMessageProcessor 处理client来拉取消息</li>
<li>QueryMessageProcessor 处理对消息的查询</li>
<li>EndTransactionProcessor 处理事务消息</li>
<li>…</li>
</ol>
<p>这些Processor分别处理不同的<code>RequestCode</code>。我们这次关心的是<code>SendMessageProcessor</code>。</p>
<p>处理的流程比较简单，这里只列出基本流程，可从<code>SendMessageProcessor#processRequest</code>看起。</p>
<ol>
<li>检查broker是否可以对外提供服务（是否到了配置的对外服务时间）</li>
<li>消息合法性校验、broker是否可写、消息写入队列是否存在等检查</li>
<li>如果是消费失败重试消息则处理其是否要进入死信队列</li>
<li>转换请求信息封装为<code>MessageExtBrokerInner</code></li>
<li>将<code>MessageExtBrokerInner</code>发给<code>MessageStore</code>进行持久化</li>
<li>处理<code>MessageStore</code>返回的结果，并根据结果用<code>BrokerStatsManager</code>做统计更新</li>
<li>封装相应信息并返回。</li>
</ol>
<h3 id="consumer与broker"><a href="#consumer与broker" class="headerlink" title="consumer与broker"></a><a target="_blank" rel="noopener" href="https://fdx321.github.io/2017/08/22/%E3%80%90RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%915-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/">consumer</a>与broker</h3><p>韩梅梅终于要收到信了。和现实一样，要么邮递员送给你，要么你自己上邮局去取信。这两种方式对应了rmq中的两种去消息方式：push（<code>DefaultMQPushConsumer</code>）和pull（<code>DefaultMQPullConsumer</code>）。这两种方式在定义上是有区别的，但实现上实际都是pull，只是对pull的处理不同。说到这里就不得不提长轮询了，pull方式我们客户端需要自己起一个线程定时去broker拉取信息，当broker没有消息可消费时立刻返回；push方式与pull流程一致，但是broker对其请求处理不同，当broker此刻无消息可消费时，broker会hold住当前请求，直到有消息返回或者到了超时时间返回。戳这里（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d3f66b1eb748">–&gt;长轮询–&lt;</a>和<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6e90c2f2e463">–&gt;长轮询进阶–&lt;</a>）更深入了解长轮询，感谢伟大的互联网让信息容易共享。</p>
<p>此处以push模式下的<code>MessageListenerConcurrently</code>消费策略来梳理下获取消息的流程。<br><code>DefaultMQPushConsumer</code>相比<code>DefaultMQProducerImpl</code>多启动了几个服务：负载均衡服务（consumer平均分配队列）、维护offset服务、消息消费服务（consumeMessageService）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultMQPushConsumer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">    <span class="comment">// 省略配置检查及服务的启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新订阅topic信息</span></span><br><span class="line">    <span class="built_in">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个topic随机选取一个broker检查subscription语法是否正确，请求code：RequestCode.CHECK_CLIENT_CONFIG</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 向broker发送心跳，心跳携带client相关信息</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行负载均衡，默认策略为`AllocateMessageQueueAveragely`，调整完后发起第一个pullRequest</span></span><br><span class="line">    <span class="built_in">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>consumer定时拉取服务是在<code>MQClientInstance</code>中启动的一个叫做pullMessageService（<code>PullMessageService</code>）的定时服务，这个服务监听在一个pullRequestQueue队列上，当有拉取请求时，根据<code>PullRequest</code>选取对应分组的<code>DefaultMQPushConsumerImpl</code>进行拉取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PullRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line">    <span class="keyword">private</span> MessageQueue messageQueue;</span><br><span class="line">    <span class="keyword">private</span> ProcessQueue processQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> nextOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">lockedFirst</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PullRequest</code>中有两个Queue，messageQueue是指要从broker哪个队列拉数据，ProcessQueue是拉数据成功后存放数据的队列。有了processQueue便可以做一些简单的流控，目前可以根据processQueue的消息数量或者消息的大小来决定是否停止本次拉取，并设置下次拉取的延迟而不是立即开始下次拉取。如果流控通过，consumer开始通过pullAPIWrapper向broker拉去信息，拉取成功后提交一个消费任务（默认非CONSUME_MESSAGE_DIRECTLY，如果此时线程池等待队列已满，任务延迟提交），消费任务回掉我们注册的listener，消息至此投递完成。</p>
<p>投递完成后，消费的结果怎么处理？我们刚提到ProcessQueue可以进行流控，那么合适出队以消费的消息？消费失败又需要做什么处理？这里不在展开，可见<code>ConsumeMessageConcurrentlyService</code>类中。</p>
<p>除了怎么去消费消息外，对consumer而言还有另外一个需要解决的问题：怎么给采用CLUSTERING方式的消费群组成员平均分配队列？答案在<code>AllocateMessageQueueAveragely</code>中，该策略保证消息队列被平均分配给同消费组内的消费者（<a target="_blank" rel="noopener" href="https://fdx321.github.io/2017/08/22/%E3%80%90RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%915-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/">图片来源</a>）。</p>
<p><img src="https://res.cloudinary.com/childe/image/upload/v1544699167/blog/mq/rmq%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%93%E6%9E%84.png" alt="rmq消费者结构"></p>
<h3 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h3><p>数据的落盘、存储、数据结构、目录结构这些请戳<a target="_blank" rel="noopener" href="https://fdx321.github.io/2017/08/22/%E3%80%90RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%916-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/">–&gt;broker的数据持久化&lt;–</a></p>
<blockquote>
<p>源代码入口 <code>CommitLog#putMessage(final MessageExtBrokerInner msg)</code><br>重要的一些基础 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f90866dcbffc">MappedFile-Java</a>、<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010858641">Java NIO</a>、<a target="_blank" rel="noopener" href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.00.md">Btree</a></p>
</blockquote>
<p>此处贴上一张关于broker数据结构及流转的图，更直观来看他的数据结构流向（<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27529917/article/details/79595395">图片来源</a>）。<br><img src="https://res.cloudinary.com/childe/image/upload/v1544697820/blog/mq/rmq%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AC%E6%8D%A2.png" alt="rmq数据结构转换.png"></p>
<h3 id="broker与broker（HA）"><a href="#broker与broker（HA）" class="headerlink" title="broker与broker（HA）"></a><a target="_blank" rel="noopener" href="https://fdx321.github.io/2017/08/22/%E3%80%90RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%916-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/">broker与broker（HA）</a></h3><p>broker有这几种角色ASYNC_MASTER、SYNC_MASTER、SLAVE，消息肯定都是写到MASTER上的，然后同步给SLAVE。</p>
<p>同步的方式分为SYNC和ASYNC两种：</p>
<ul>
<li>ASYNC，消息写完后就直接返回，后台线程去做同步的操作;</li>
<li>SYNC，等到同步完成后返回。</li>
</ul>
<p>这两种方式也称作异步复制和同步双写。HA的整个过程只在store模块做的，是基于JDK的nio来写的，没有依赖remoting模块。</p>
<p>除此之外，broker启动时，如果当前broker是SLAVE，则会启动一个定时任务来同步topic等信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SlaveSynchronize</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.syncTopicConfig();</span><br><span class="line">    <span class="built_in">this</span>.syncConsumerOffset();</span><br><span class="line">    <span class="built_in">this</span>.syncDelayOffset();</span><br><span class="line">    <span class="built_in">this</span>.syncSubscriptionGroupConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上只是对整体架构和主流成的简单认知，关于其中的细节问题，就需要我们带着疑问去看源码了。</p>
<blockquote>
<p>问题：<br>怎么处理定时消息？<br>消费失败的消息怎么处理？<br>链接是否像dubbo那样复用？<br>broker的数据结构是怎样的？<br>broker怎么保证存储高吞吐?<br>broker怎么过滤消息？</p>
</blockquote>
<p>“古人学问无遗力，少壮工夫老始成。纸上得来终觉浅，绝知此事要躬行。” – 陆游《冬夜读书示子聿》</p>
<p>以上贴出源代码基于<a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq">incubator-rocketmq</a> release-4.3.2版本，为了方便均有删减改，但不影响实际流程。</p>
<p>小生不才，以上如有描述有误的地方还望各位不吝赐教 !^_^！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://alibaba.github.io/RocketMQ-docs/document/design/RocketMQ_design.pdf">RocketMQ 原理简介</a></p>
<p><a target="_blank" rel="noopener" href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164726/RocketMQ_userguide.pdf">rocketmq 用户指南</a></p>
<p><a target="_blank" rel="noopener" href="http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164929/RocketMQ_experience.pdf">RocketMQ 最佳实践</a></p>
<p><a target="_blank" rel="noopener" href="http://ifeve.com/%E3%80%8Aapache-rocketmq%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%E3%80%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/">译-apache-rocketmq用户指南</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/vintagewang/document/tree/master/rocketmq">誓嘉(rmq作者)文档</a></p>
<p><a target="_blank" rel="noopener" href="http://alibaba.github.io/RocketMQ-docs/document/openuser/RocketMQ_admin.pdf">RocketMQ 运维指令</a></p>
<p><a target="_blank" rel="noopener" href="https://fdx321.github.io/2017/08/16/%E3%80%90RocketMQ%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E3%80%911-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/">rmq源码系列</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011003778#articleHeader8">RocketMQ源码学习(三)-Broker(与Producer交互部分)</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010858641">Java NIO-阅读笔记及总结</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f90866dcbffc">深入浅出MappedByteBuffer</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27529917/article/details/79595395">rmq数据结构转换图片来源</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag"># 架构</a>
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
              <a href="/tags/MQ/" rel="tag"># MQ</a>
              <a href="/tags/rocketmq/" rel="tag"># rocketmq</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/10/23/%E7%AC%94%E8%AE%B0-JMH-Java-Microbenchmark-Harness/" rel="prev" title="JMH(Java Microbenchmark Harness)笔记">
      <i class="fa fa-chevron-left"></i> JMH(Java Microbenchmark Harness)笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/01/13/rocketmq-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%88%86%E6%9E%90/" rel="next" title="rocketmq-消息重复分析">
      rocketmq-消息重复分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E7%BB%93%E6%9E%84%EF%BC%88%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">部署结构（逻辑结构&#x2F;物理结构）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">物理结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">逻辑结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%92%E8%89%B2%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E4%BA%A4%E4%BA%92"><span class="nav-number">2.</span> <span class="nav-text">角色实现及其交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namesrv-Name-Server-%E4%B8%8Ebroker"><span class="nav-number">2.1.</span> <span class="nav-text">namesrv(Name Server)与broker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#namesrv-Name-Server"><span class="nav-number">2.1.1.</span> <span class="nav-text">namesrv(Name Server)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#broker"><span class="nav-number">2.1.2.</span> <span class="nav-text">broker</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namesrv%E4%B8%8Eproducer"><span class="nav-number">2.2.</span> <span class="nav-text">namesrv与producer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namesrv%E4%B8%8Econsumer"><span class="nav-number">2.3.</span> <span class="nav-text">namesrv与consumer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#producer%E4%B8%8Ebroker"><span class="nav-number">2.4.</span> <span class="nav-text">producer与broker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="nav-number">2.4.1.</span> <span class="nav-text">消息发送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6"><span class="nav-number">2.4.2.</span> <span class="nav-text">消息接收</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#consumer%E4%B8%8Ebroker"><span class="nav-number">2.5.</span> <span class="nav-text">consumer与broker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="nav-number">2.6.</span> <span class="nav-text">消息存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#broker%E4%B8%8Ebroker%EF%BC%88HA%EF%BC%89"><span class="nav-number">2.7.</span> <span class="nav-text">broker与broker（HA）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">3.</span> <span class="nav-text">结语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">4.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="childe.chen"
      src="https://res.cloudinary.com/childe/image/upload/v1535291056/1_myjcxd.png">
  <p class="site-author-name" itemprop="name">childe.chen</p>
  <div class="site-description" itemprop="description">少爷凡隐</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">childe.chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
